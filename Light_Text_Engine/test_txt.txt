Combinatorics is a subfield of “discrete mathematics,” so we should begin by asking what
discrete mathematics means. The differences are to some extent a matter of opinion, and
various mathematicians might classify specific topics differently.
“Discrete” should not be confused with “discreet,” which is a much more commonly-used
word. They share the same Latin root, “discretio,” which has to do with wise discernment or
separation. In the mathematical “discrete,” the emphasis is on separateness, so “discrete” is
the opposite of “continuous.” If we are studying objects that can be separated and treated as
a (generally countable) collection of units rather than a continuous structure, then this study
falls into discrete mathematics.
In calculus, we deal with continuous functions, so calculus is not discrete mathematics. In
linear algebra, our matrices often have real entries, so linear algebra also does not fall into
discrete mathematics.
Text books on discrete mathematics often include some logic, as discrete mathematics is
often used as a gateway course for upper-level math. Elementary number theory and set theory
are also sometimes covered. Algorithms are a common topic, as algorithmic techniques tend to
work very well on the sorts of structures that we study in discrete mathematics.
In Combinatorics, we focus on combinations and arrangements of discrete structures. There
are five major branches of combinatorics that we will touch on in this course: enumeration, graph
theory, Ramsey Theory, design theory, and coding theory. (The related topic of cryptography
can also be studied in combinatorics, but we will not touch on it in this course.) We will focus
on enumeration, graph theory, and design theory, but will briefly introduce the other two topics.
1.1. Enumeration
Enumeration is a big fancy word for counting. If you’ve taken a course in probability and
statistics, you’ve already covered some of the techniques and problems we’ll be covering in
this course. When a statistician (or other mathematician) is calculating the “probability” of a
particular outcome in circumstances where all outcomes are equally likely, what they usually do
is enumerate all possible outcomes, and then figure out how many of these include the outcome
they are looking for.
EXAMPLE 1.1.1. What is the probability of rolling a 3 on a 6-sided die?
SOLUTION. To figure this out, a mathematician would count the sides of the die (there are
six) and count how many of those sides display a three (one of them). They would conclude
that the probability of rolling a 3 on a 6-sided die is 1/6 (one in six).
1
2 1. What is Combinatorics?
That was an example that you could probably figure out without having studied enumeration or probability, but it nonetheless illustrates the basic principle behind many calculations
of probability. The object of enumeration is to enable us to count outcomes in much more
complicated situations. This sometimes has natural applications to questions of probability,
but our focus will be on the counting, not on the probability.
After studying enumeration in this course, you should be able to solve problems such as:
If you are playing Texas Hold’em poker against a single opponent, and the two cards
in your hand are a pair, what is the probability that your opponent has a higher pair?
How many distinct Shidokus (4-by-4 Sudokus) are there?
How many different orders of five items can be made from a bakery that makes three
kinds of cookies?
Male honeybees come from a queen bee’s unfertilised eggs, so have only one parent
(a female). Female honeybees have two parents (one male, one female). Assuming
all ancestors were distinct, how many ancestors does a male honeybee have from 10
generations ago?
Although all of these questions (and many others that arise naturally) may be of interest
to you, the reason we begin our study with enumeration is because we’ll be able to use many
of the techniques we learn, to count the other structures we’ll be studying.
1.2. Graph Theory
When a mathematician talks about graph theory, they are not referring to the “graphs” that
you learn about in school, that can be produced by a spreadsheet or a graphing calculator. The
“graphs” that are studied in graph theory are models of networks.
Any network can be modeled by using dots to represent the nodes of the network (the cities,
computers, cell phones, or whatever is being connected) together with lines to represent the
connections between those nodes (the roads, wires, wireless connections, etc.). This model is
called a graph. It is important to be aware that only at a node may information, traffic, etc.
pass from one edge of a graph to another edge. If we want to model a highway network using a
graph, and two highways intersect in the middle of nowhere, we must still place a node at that
intersection. If we draw a graph in which edges cross over each other but there is no node at
that point, you should think of it as if there is an overpass there with no exits from one highway
to the other: the roads happen to cross, but they are not connecting in any meaningful sense.
EXAMPLE 1.2.1. The following diagram:
Fort Macleod Lethbridge Medicine Hat
Calgary
Strathmore
is a graph.
Many questions that have important real-world applications can be modeled with graphs.
These are not always limited to questions that seem to apply to networks. Some questions
can be modeled as graphs by using lines to represent constraints or some other relationship
between them (e.g. the nodes might represent classes, with a line between them if they cannot
1. What is Combinatorics? 3
be scheduled at the same time, or some nodes might represent students and others classes, with
a line between a student and each of the classes they are taking).
After studying graph theory in this course, you should be able to solve problems such as:
How can we find a good route for garbage trucks to take through a particular city?
Is there a delivery route that visits every city in a particular area, without repetition?
Given a collection of project topics and a group of students each of whom has expressed
interest in some of the topics, is it possible to assign each student a unique topic that
interests them?
A city has bus routes all of which begin and end at the bus terminal, but with different
schedules, some of which overlap. What is the least number of buses (and drivers)
required in order to be able to complete all of the routes according to the schedule?
Create a schedule for a round-robin tournament that uses as few time slots as possible.
Some of these questions you may only be able to answer for particular kinds of graphs.
Graph theory is a relatively “young” branch of mathematics. Although some of the problems
and ideas that we will study date back a few hundred years, it was not until the 1930s that
these individual problems were gathered together and a unified study of the theory of graphs
began to develop.
1.3. Ramsey Theory
Ramsey theory takes its name from Frank Plumpton Ramsey (1903—1930), a British mathematician who died at the tragically young age of 26.
Ramsey was a logician. A result that he considered a minor lemma in one of his logic papers
now bears the name “Ramsey’s Theorem” and was the basis for this branch of mathematics.
Its statement requires a bit of graph theory: given c colours and fixed sizes n1, . . . , nc, there is
an integer r = R(n1, . . . , nc) such that for any colouring the edges of of a complete graph on r
vertices, there must be some i between 1 and c such that there is a complete subgraph on ni
vertices, all of whose edges are coloured with colour i.
In addition to requiring some graph theory, that statement was a bit technical. In much
less precise terms that don’t require so much background knowledge (but could be misleading
in specific situations), Ramsey theory asserts that if a structure is big enough and contains a
property we are interested in, then no matter how we cut it into (a limited number of) pieces, at
least one of the pieces should also have that property. One major theorem in Ramsey theory is
van der Waerden’s Theorem, which states that for any two constants c and n, there is a constant
V (c, n) such that if we take V (c, n) consecutive numbers and colour them with c colours, there
must be an arithmetic progression of length n all of whose members have been coloured with
the same colour.
EXAMPLE 1.3.1. Here is a small example of van der Waerden’s Theorem. With two colours
and a desired length of 3 for the arithmetic progression, we can show that V (2, 3) > 8 using
the following colouring:
3 4 5 6 7 8 9 10
(In case it is difficult to see, we point out that 3, 4, 7, and 8 are black, while 5, 6, 9, and 10
are grey, a different colour.) Notice that with eight consecutive integers, the difference in a
three-term arithmetic progression cannot be larger than three. For every three-term arithmetic
progression with difference of one, two, or three, it is straightforward to check that the numbers
have not all received the same colour.
In fact, V (2, 3) = 9, but proving this requires exhaustive testing.
4 1. What is Combinatorics?
We will touch lightly on Ramsey theory in this course, specifically on Ramsey’s Theorem
itself, in the context of graph theory.
1.4. Design Theory
Like graph theory, design theory is probably not what any non-mathematician might expect
from its name.
When researchers conduct an experiment, errors can be introduced by many factors (including, for example, the timing or the subject of the experiment). It is therefore important to
replicate the experiment a number of times, to ensure that these unintended variations do not
account for the success of a particular treatment. If a number of different treatments are being
tested, replicating all of them numerous times becomes costly and potentially infeasible. One
way to reduce the total number of trials while still maintaining the accuracy, is to test multiple
treatments on each subject, in different combinations.
One of the major early motivations for design theory was this context: given a fixed number
of total treatments, and a fixed number of treatments we are willing to give to any subject, can
we find combinations of the possible treatments so that each treatment is given to some fixed
number of subjects, and any pair of treatments is given together some fixed number of times
(often just once). This is the basic structure of a block design.
EXAMPLE 1.4.1. Suppose that we have seven different fertilisers and seven garden plots on
which to try them. We can organise them so that each fertiliser is applied to three of the plots,
each garden plot receives three fertilisers, and any pair of fertilisers is used together on precisely
one of the plots. If the different fertilisers are numbered one through seven, then a method for
arranging them is to place fertilisers 1, 2, and 3 on the first plot; 1, 4, and 5 on the second; 1,
6, and 7 on the third; 2, 4, and 6 on the fourth; 2, 5, and 7 on the fifth; 3, 4, and 7 on the
sixth; and3, 5, and 6 on the last. Thus,
123 145 167
246 257 347
356
is a design.
This basic idea can be generalised in many ways, and the study of structures like these is
the basis of design theory. In this course, we will learn some facts about when designs exist,
and how to construct them.
After studying design theory in this course, you should be able to solve problems such as:
Is it possible for a design to exist with a particular set of parameters?
What methods might we use in trying to construct a design?
1.5. Coding Theory
In many people’s minds “codes” and “cryptography” are inextricably linked, and they might
be hard-pressed to tell you the difference. Nonetheless, the two topics are vastly different, as is
the mathematics involved in them.
Coding theory is the study of encoding information into different symbols. When someone
uses a code in an attempt to make a message that only certain other people can read, this
becomes cryptography. Cryptographers study strategies for ensuring that a code is difficult to
“break” for those who don’t have some additional information. In coding theory, we ignore the
question of who has access to the code and how secret it may be. Instead, one of the primary
concerns becomes our ability to detect and correct errors in the code.
1. What is Combinatorics? 5
Codes are used for many purposes in which the information is not intended to be secret. For
example, computer programs are transformed into long strings of binary data, that a computer
reinterprets as instructions. When you text a photo to a friend, the pixel and colour information
are converted into binary data to be transmitted through radio waves. When you listen to an
audio file, the sound frequencies of the music have been converted into binary data that your
computer decodes back into sound frequencies.
Electronic encoding is always subject to interference, which can cause errors. Even when
a coded message is physically etched onto a device (such as a dvd), scratches can make some
parts of the code illegible. When you are connected to the internet (for example, if you are
streaming), wifi signals can fail, suffer interference from other nearby networks, or become
overloaded. Any of these problems can cause your connection to lose or misread part of the
data that is being transmitted. People don’t like it when their movies, music, or apps freeze,
crash, or skip over something. This can become even more problematic if it happens during an
important online meeting or class, or while you are making an electronic financial transaction.
To avoid this problem, engineers use codes that allow our devices to automatically detect, and
correct, minor errors that may be introduced.
In coding theory, we learn how to create codes that allow for error detection and correction,
without requiring excessive memory or storage capacity. Although coding theory is not a focus
of this course, designs can be used to create good codes. We will learn how to make codes from
designs, and what makes these codes “good.”
EXAMPLE 1.5.1. Suppose we have a string of binary information, and we want the computer
to store it so we can detect if an error has arisen. There are two symbols we need to encode: 0
and 1. If we just use 0 as the code for indicating 0 and 1 as the code for 1, we’ll never know if a
bit has been flipped (from 0 to 1 or vice versa). If we use 00 for 0 and 01 for 1, then if the first
bit gets flipped we’ll know there was an error (because the first bit should never be 1), but we
won’t notice if the second was flipped. If we use 00 for 0 and 11 for 1, then we will be able to
detect an error, as long as at most one bit gets flipped, because flipping one bit of either code
word will result in either 01 or 10, neither of which is a valid code word. Thus, this code allows
us to detect an error. It does not allow us to correct an error, because even knowing that a
single bit has been flipped, there is no way of knowing whether a 10 arose from a 00 with the
first bit flipped, or from a 11 with the second bit flipped. We would need a longer code to be
able to correct errors.
After our study of coding theory, you should be able to solve problems such as:
Given a code, how many errors can be detected?
Given a code, how many errors can be corrected?
Construct some small codes that allow detection and correction of small numbers of
errors.
EXERCISE 1.5.2. Can you come up with an interesting counting problem that you wouldn’t
know how to solve?